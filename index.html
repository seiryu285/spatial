<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Three.jsとMediaPipe Handsの改良版</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: black;
    }
    #startButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #3498db;
      color: white;
      font-size: 20px;
      padding: 15px 30px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #error {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: red;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
    }
    #videoElement {
      display: none;
    }
  </style>
</head>
<body>
  <button id="startButton">Start Experience</button>
  <canvas id="canvas"></canvas>
  <video id="videoElement"></video>
  <div id="error"></div>

  <!-- 必要なスクリプトを読み込み -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const canvas = document.getElementById('canvas');
      const videoElement = document.getElementById('videoElement');
      const startButton = document.getElementById('startButton');
      const errorDiv = document.getElementById('error');

      let isStarted = false;
      let error = null;

      let scene, camera, renderer;
      let sphere, particles, warpParticles;
      let handMesh, pinchIndicator;
      let isPinching = false;
      let pinchStartPosition = new THREE.Vector3();
      let originalScale = new THREE.Vector3(1, 1, 1);
      const wallZ = -20;
      let isWarping = false;
      let lastHandPosition = new THREE.Vector3();
      let handVelocity = new THREE.Vector3();

      let mediaPipeHands = null;

      // 手の位置とピンチ距離の履歴を保持するための配列
      const handPositionHistory = [];
      const pinchDistanceHistory = [];
      const maxHistoryLength = 5; // 履歴の長さ

      function handleError(err) {
        console.error('エラーが発生しました:', err);
        error = err.message;
        if (errorDiv) {
          errorDiv.textContent = error;
        }
      }

      function init() {
        try {
          scene = new THREE.Scene();
          camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
          renderer.setSize(window.innerWidth, window.innerHeight);

          createSphere();
          createWall();
          createParticles();
          createWarpParticles();
          createHandMesh();
          createPinchIndicator();

          camera.position.z = 5;

          window.addEventListener('resize', onWindowResize, false);

          animate();
        } catch (err) {
          handleError(err);
        }
      }

      function createSphere() {
        const geometry = new THREE.SphereGeometry(1, 64, 64);
        const material = new THREE.MeshPhongMaterial({
          color: 0x3498db,
          specular: 0x333333,
          shininess: 100,
        });
        sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        const light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(10, 10, 10);
        scene.add(light);
      }

      function createWall() {
        const wallGeometry = new THREE.PlaneGeometry(40, 40);
        const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide });
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        wall.position.z = wallZ;
        scene.add(wall);
      }

      function createParticles() {
        const particleCount = 1000;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i++) {
          particlePositions[i] = (Math.random() - 0.5) * 10;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        const particleMaterial = new THREE.PointsMaterial({
          color: 0x3498db,
          size: 0.05,
          blending: THREE.AdditiveBlending,
          transparent: true,
          opacity: 0.8
        });

        particles = new THREE.Points(particleGeometry, particleMaterial);
        particles.visible = false;
        scene.add(particles);
      }

      function createWarpParticles() {
        const particleCount = 10000;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
          const r = 50 + Math.random() * 100;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;

          particlePositions[i] = r * Math.sin(phi) * Math.cos(theta);
          particlePositions[i + 1] = r * Math.sin(phi) * Math.sin(theta);
          particlePositions[i + 2] = r * Math.cos(phi);
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        const particleMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.1,
          blending: THREE.AdditiveBlending,
          transparent: true,
          opacity: 0
        });

        warpParticles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(warpParticles);
      }

      function createHandMesh() {
        const geometry = new THREE.SphereGeometry(0.1, 32, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7 });
        handMesh = new THREE.Mesh(geometry, material);
        scene.add(handMesh);
      }

      function createPinchIndicator() {
        const geometry = new THREE.RingGeometry(0.05, 0.07, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
        pinchIndicator = new THREE.Mesh(geometry, material);
        pinchIndicator.visible = false;
        scene.add(pinchIndicator);
      }

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);

        if (isWarping) {
          warpParticles.rotation.y += 0.01;
        }

        // 手の移動をスムーズにする
        if (handMesh) {
          handMesh.position.add(handVelocity);
          handVelocity.multiplyScalar(0.9); // 減衰係数
        }
      }

      function onPinchStart(position) {
        isPinching = true;
        pinchStartPosition.copy(position);
        originalScale.copy(sphere.scale);
        pinchIndicator.visible = true;
        pinchIndicator.position.copy(position);
      }

      function onPinchMove(position) {
        if (isPinching) {
          const dragVector = new THREE.Vector3().subVectors(position, pinchStartPosition);
          const dragDistance = dragVector.length();

          sphere.scale.set(
            originalScale.x - dragDistance * 0.1,
            originalScale.y - dragDistance * 0.1,
            originalScale.z + dragDistance * 0.5
          );
          sphere.position.copy(pinchStartPosition).add(dragVector.multiplyScalar(0.5));

          // 引っ張る感覚を強化
          const elasticForce = dragVector.clone().multiplyScalar(-0.1);
          sphere.position.add(elasticForce);

          pinchIndicator.position.copy(position);
        }
      }

      function onPinchEnd() {
        if (isPinching) {
          isPinching = false;
          pinchIndicator.visible = false;
          const velocity = new THREE.Vector3().subVectors(sphere.position, pinchStartPosition);
          launchSphere(velocity);
        }
      }

      function launchSphere(velocity) {
        gsap.to(sphere.position, {
          x: 0,
          y: 0,
          z: wallZ,
          duration: 1,
          ease: "power1.in",
          onComplete: onSphereCollision
        });

        gsap.to(sphere.scale, {
          x: originalScale.x,
          y: originalScale.y,
          z: originalScale.z,
          duration: 0.5
        });
      }

      function onSphereCollision() {
        sphere.visible = false;
        particles.visible = true;
        particles.position.copy(sphere.position);

        gsap.to(particles.material, {
          opacity: 1,
          duration: 0.2,
          onComplete: startWarpEffect
        });

        const particlePositions = particles.geometry.attributes.position.array;
        for (let i = 0; i < particlePositions.length; i += 3) {
          gsap.to(particlePositions, {
            [i]: particlePositions[i] + (Math.random() - 0.5) * 20,
            [i + 1]: particlePositions[i + 1] + (Math.random() - 0.5) * 20,
            [i + 2]: particlePositions[i + 2] + (Math.random() - 0.5) * 20,
            duration: 1,
            ease: "power2.out"
          });
        }
        particles.geometry.attributes.position.needsUpdate = true;
      }

      function startWarpEffect() {
        isWarping = true;
        gsap.to(warpParticles.material, {
          opacity: 0.5,
          duration: 2,
          ease: "power1.in"
        });

        gsap.to(camera.position, {
          z: 1000,
          duration: 5,
          ease: "power2.in"
        });

        gsap.to(warpParticles.rotation, {
          x: Math.PI * 2,
          y: Math.PI * 2,
          duration: 5,
          ease: "power2.in",
          onComplete: () => {
            console.log("時空間移動完了！");
            isWarping = false;
          }
        });
      }

      function onWindowResize() {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      function calculateDistance(a, b) {
        return Math.sqrt(
          Math.pow(a.x - b.x, 2) +
          Math.pow(a.y - b.y, 2) +
          Math.pow(a.z - b.z, 2)
        );
      }

      function handleStart() {
        isStarted = true;
        startButton.style.display = 'none';
        init();

        if (videoElement) {
          try {
            const hands = new Hands({
              locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
              },
            });
            hands.setOptions({
              maxNumHands: 1,
              modelComplexity: 2, // 複雑なモデルを使用
              minDetectionConfidence: 0.8, // 信頼度を上げる
              minTrackingConfidence: 0.8,
              selfieMode: true,
            });
            hands.onResults(onResults);

            // カメラの設定をモバイルデバイスに合わせて調整
            const constraints = {
              video: {
                facingMode: 'user', // フロントカメラを使用
                width: { ideal: 640 },
                height: { ideal: 480 }
              }
            };

            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
              videoElement.srcObject = stream;
              videoElement.play();

              const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                  await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480,
              });
              cameraUtils.start();
            }).catch((err) => {
              handleError(new Error(`カメラへのアクセスが拒否されました: ${err.message}`));
            });
          } catch (err) {
            handleError(new Error(`手の追跡の初期化に失敗しました: ${err.message}`));
          }
        }
      }

      function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          const landmarks = results.multiHandLandmarks[0];

          const indexFingerTip = landmarks[8];
          const thumbTip = landmarks[4];

          // 手の位置を計算
          const rawHandPosition = new THREE.Vector3(
            (indexFingerTip.x - 0.5) * 10,
            (indexFingerTip.y - 0.5) * -10,
            -indexFingerTip.z * 10
          );

          // 手の位置の履歴を更新
          handPositionHistory.push(rawHandPosition.clone());
          if (handPositionHistory.length > maxHistoryLength) {
            handPositionHistory.shift();
          }

          // 手の位置を平滑化
          const smoothedHandPosition = new THREE.Vector3();
          handPositionHistory.forEach(pos => smoothedHandPosition.add(pos));
          smoothedHandPosition.divideScalar(handPositionHistory.length);

          // 手の速度を計算してスムーズな動きを実現
          handVelocity.subVectors(smoothedHandPosition, lastHandPosition).multiplyScalar(0.2);
          lastHandPosition.copy(smoothedHandPosition);

          // 手の可視化を更新
          handMesh.position.copy(smoothedHandPosition);

          // ピンチ距離の計算
          const pinchDistance = calculateDistance(thumbTip, indexFingerTip);

          // ピンチ距離の履歴を更新
          pinchDistanceHistory.push(pinchDistance);
          if (pinchDistanceHistory.length > maxHistoryLength) {
            pinchDistanceHistory.shift();
          }

          // ピンチ距離を平滑化
          const smoothedPinchDistance = pinchDistanceHistory.reduce((a, b) => a + b, 0) / pinchDistanceHistory.length;

          // ピンチ状態を更新
          const pinchThreshold = 0.025; // 閾値
          const isPinchingNow = smoothedPinchDistance < pinchThreshold;

          // ピンチ状態の変化を検出
          if (isPinchingNow && !isPinching) {
            onPinchStart(smoothedHandPosition);
          } else if (!isPinchingNow && isPinching) {
            onPinchEnd();
          }

          if (isPinching) {
            onPinchMove(smoothedHandPosition);
          }

          // ワープパーティクルとの相互作用
          if (isWarping) {
            const distanceToCenter = smoothedHandPosition.length();
            if (distanceToCenter < 5) {
              warpParticles.rotation.x += smoothedHandPosition.y * -0.01;
              warpParticles.rotation.y += smoothedHandPosition.x * 0.01;
            }
          }
        } else {
          // 手が検出されない場合、過去の手の位置を保持
          if (handPositionHistory.length > 0) {
            const lastPosition = handPositionHistory[handPositionHistory.length - 1];
            handPositionHistory.push(lastPosition);
            if (handPositionHistory.length > maxHistoryLength) {
              handPositionHistory.shift();
            }
          }
        }
      }

      startButton.addEventListener('click', handleStart);
    });
  </script>
</body>
</html>

